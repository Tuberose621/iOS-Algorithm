# 排序

如何来评价一个排序算法的好坏？

有下面三个方面:

1. 时间复杂度，最好情况，最坏情况，平均时间复杂度?
2. 空间复杂度，是否是原地排序？
3. 稳定性，如果待排序的序列中存在值相同的元素，那么经过排序后，相等元素之间原来的顺序是否变化？



## 冒泡,插入,选择O(n^2)

这两种算法的原理是差不多的:


1. 将待排序数组分为已排序和未排序两部分
2. 每次排序，将未排序部分的某个元素移动到已排序部分指定的位置
3. 重复N次

所以，它们都是两层循环，外层循环控制轮数，内层循环把元素移动到指定的位置。

对于冒泡来说，它的内层循环做的事情，就是比较相邻元素的值，然后把较大的值放到右边，这样一轮下来，最大的值就在右边。重复N次，那么整个数组就有序了.


### [冒泡](./sort/bubbleSort.h)
### 性能分析:

 1. 最好：o(n)，比如 待排序数组 1,2,3,4,5，循环一次
 2. 最坏 o(n^2),比如 待排序数组 5，4，3，2，1
 3. 平均 o(n^2)
 4. 属于原地排序,O(1)
 5. 属于稳定排序

 

-----------------------

选择排序，它的内层循环做的事情，就是把未排序部分的元素依次插入到有序部分的指定位置去。这样外层循环每一轮下来，未排序部分的长度减一，直到未排序部分全部排序完，整个数组就有序了。


### [插入](./sort/insertSort.h)


### 性能分析:

1. 最好: O(n),比如 待排序数组 1,2,3,4,5，循环一次
2. 最坏:O(n^2),比如 5，4，3，2，1
3. 平均:O(n^2)
4. 属于原地排序，O(1)
5. 属于稳定排序


--------------------

选择排序，它的内层循环做的事情，就是在未排序部分找到最小的元素，然后放在有序部分的末尾，这样N轮下来，未排序部分的长度每次减一，最后整个数组就有序了。

### [选择](./sort/selectSort.h)


### 性能分析

1. 最好,最坏，平均都是O(n^2),因为每次都会在未排序部分找最小.
2. 属于原地排序,O(1)
3. 非稳定，比如5,8,5,2,9。第一轮下来，2和5交换，那么这两个5的顺序就发生变化了.


这三种算法，选择排序是最戳的，冒泡和插入相当，但是插入性能会比冒泡更好，因为冒泡里面核心步骤是交换，而插入排序核心步骤是移位和赋值，它的指令会更少些.


--------------------


## 归并和快排

前面的O(n^2)的算法适合小规模的数据排序，当涉及到大规模数据的排序问题，归并和快爬就用的上了.

归并和快排都用到了分治思想，非常巧妙。

归并排序的思想：如果要排序一个数组，我们先将数组从中间分为两部分，然后分别对两部分排序，最后再将排序好的两部分合并在一起。


### [归并](./sort/mergeSort.h)

### 性能分析

1.  merge函数的实现里面，我们可以看出首先会N次循环构建一个temp临时排好序的数组，然后依次拷贝。所以归并排序的执行效率和要排序数组的有序程度是无关的，所以时间复杂度是非常稳定的，不管是最好，最坏，平均都是o(n*log(n))
2. 非本地排序
3. 稳定排序，不改变相等元素之前的顺序


-------------------

快排的思想也是利用分治，在待排数组中找到一个数，它前面的数都比它小，它后面的数都比它大。在继续左边部分和右边部分。

### [快排](./sort/quickSort.h)


### 性能分析

1. 大部分情况下都能做到O(n*log(n))
2. 最坏情况下，O(n^2)，比如数组本身就是有序的，它将会进行N次分区
3. 原地排序,O(1)
4. 非稳定排序



### [如何在o(n)内查找一个无序数组中的第K大元素](./sort/kthSmallest.h)

-----------------------


## 使用场景苛刻的线性排序(桶排序，计数排序，基数排序)O(n)

这三种排序的是O(n)级别的排序算法，不过它们对排序数据的要求极其严格，之所以能做到线性的时间复杂度，主要原因是，这三种算法是非基于比较的算法，都不涉及元素间的比较。


这三种算法对排序数据要求很严苛，重点自傲与理解这些排序算法适用的场景.


### 桶排序

桶排序的核心思想是：将要排序的数据分到几个有序的桶里，每个桶再单独排序，最后根据桶的顺序依次取出，组成的序列就有序的。这里对数据的要求有几方面:

1. 待排序数据要很容易就能分进M个桶里
2. 并且这桶和桶之间天然的就是有序的
3. 每个桶里面的元素要劲量平均，不然算法就会退化大O。


### [桶排序代码](./sort/bucketSort.h)


### 计数排序

计数排序是一种特殊情况下的桶排序，在这里每个桶的划分力度为1个单位，所以每个桶内部是不需要重新排序的。很容易理解.

计数排序适合用在数据范围不大的场景中，如果数据范围比要排序的数据n大很多的话，那么就不适合计数排序了。

### [计数排序代码](./sort/countingSort.h)






| &emsp;题号&emsp; | 题目链接&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| 答案链接&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| &emsp;难度&emsp;  | &emsp;完成度&emsp;  |
| :--: | :--: | :----------------------------------------------------------- | :----------------------------------------------------------- | :------: | :------: |
|  56  | [合并区间](https://leetcode-cn.com/problems/merge-intervals/) | [merge_intervals](./sort/leetcode/merge_intervals.h) | <font color=orange> medium </font> | ✅ |
|  75  | [颜色分类](https://leetcode-cn.com/problems/sort-colors/) | [sort_colors](./sort/leetcode/sort_colors.h) | <font color=orange> medium </font> | ✅ |